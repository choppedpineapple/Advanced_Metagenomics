#!/usr/bin/env python3
import sys
import gzip
from collections import Counter
import edlib


def open_maybe_gz(path):
    if path.endswith(".gz"):
        return gzip.open(path, "rt")
    return open(path, "rt")


def fasta_reader(path):
    fh = open_maybe_gz(path)
    header = None
    seq_chunks = []
    for line in fh:
        line = line.strip()
        if not line:
            continue
        if line.startswith(">"):
            if header is not None:
                yield header, "".join(seq_chunks).upper()
            header = line[1:].split()[0]
            seq_chunks = []
        else:
            seq_chunks.append(line)
    if header is not None:
        yield header, "".join(seq_chunks).upper()
    fh.close()


def best_hit(seq, linker, linker_rc, max_ed, min_overlap, restrict_start, restrict_end):
    if restrict_start is not None or restrict_end is not None:
        rs = 0 if restrict_start is None else max(0, restrict_start)
        re = len(seq) if restrict_end is None else min(len(seq), restrict_end)
        target = seq[rs:re]
        offset = rs
    else:
        target = seq
        offset = 0

    a1 = edlib.align(linker, target, mode="HW", task="path", k=max_ed)
    a2 = edlib.align(linker_rc, target, mode="HW", task="path", k=max_ed)

    candidates = []

    for orient, aln in (("FWD", a1), ("RC", a2)):
        if aln["editDistance"] == -1:
            continue
        locs = aln.get("locations") or []
        if not locs:
            continue
        start_t, end_t = min(locs, key=lambda x: x[0])  # leftmost
        overlap_len = end_t - start_t + 1
        if overlap_len < min_overlap:
            continue
        candidates.append((aln["editDistance"], -overlap_len, start_t, orient, start_t + offset, end_t + offset))

    if not candidates:
        return None

    # sort: smallest edit distance, longest overlap, leftmost start
    best = sorted(candidates)[0]
    ed, neg_ov, st_t, orient, start, end = best
    variant = seq[start:end + 1]
    return orient, ed, start, end, variant


def to_int_or_none(x):
    if x is None:
        return None
    x = x.strip()
    if x == "" or x.lower() == "none":
        return None
    return int(x)


def main():
    if len(sys.argv) < 5:
        sys.stderr.write(
            "Usage:\n"
            "  python3 count_linker_variants.py <input.fasta[.gz]> <linker> <linker_rc> <out.tsv> "
            "[max_ed=4] [min_overlap=35] [restrict_start=None] [restrict_end=None]\n"
        )
        sys.exit(1)

    fasta_path = sys.argv[1]
    linker = sys.argv[2].upper()
    linker_rc = sys.argv[3].upper()
    out_tsv = sys.argv[4]

    max_ed = int(sys.argv[5]) if len(sys.argv) > 5 else 4
    min_overlap = int(sys.argv[6]) if len(sys.argv) > 6 else 35
    restrict_start = to_int_or_none(sys.argv[7]) if len(sys.argv) > 7 else None
    restrict_end = to_int_or_none(sys.argv[8]) if len(sys.argv) > 8 else None

    variant_counts = Counter()
    orient_counts = Counter()
    ed_hist = Counter()
    len_hist = Counter()

    n_total = 0
    n_hit = 0

    for rid, seq in fasta_reader(fasta_path):
        n_total += 1
        hit = best_hit(seq, linker, linker_rc, max_ed, min_overlap, restrict_start, restrict_end)
        if hit is None:
            continue
        orient, ed, start, end, variant = hit
        n_hit += 1
        variant_counts[variant] += 1
        orient_counts[orient] += 1
        ed_hist[ed] += 1
        len_hist[len(variant)] += 1

    with open(out_tsv, "w") as out:
        out.write("variant_seq\tcount\tvariant_len\n")
        for var, c in variant_counts.most_common():
            out.write(f"{var}\t{c}\t{len(var)}\n")

    # Summary to stdout (nice for bash logs)
    print("=== Linker variant counting summary ===")
    print(f"Total reads:\t{n_total}")
    print(f"Reads with linker hit:\t{n_hit}")
    print(f"Reads without hit:\t{n_total - n_hit}")
    print(f"Sanity sum(counts):\t{sum(variant_counts.values())}  (should equal reads with hit)")
    print("Orientation counts:\t" + "  ".join([f"{k}:{v}" for k, v in orient_counts.items()]))

    print("EditDist histogram:")
    for ed in sorted(ed_hist):
        print(f"  {ed}\t{ed_hist[ed]}")

    print("VariantLen histogram (top 10 by freq):")
    for ln, c in sorted(len_hist.items(), key=lambda x: x[1], reverse=True)[:10]:
        print(f"  {ln}\t{c}")


if __name__ == "__main__":
    main()
